{"meta":{"title":"zqzess's Blog","subtitle":"尚余发否","description":"心之所向，行之所往","author":"zqzess","url":"https://www.whitemoon.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-10-27T01:07:05.499Z","updated":"2021-02-10T07:06:14.000Z","comments":false,"path":"/404.html","permalink":"https://www.whitemoon.top/404.html","excerpt":"","text":"404"},{"title":"热门文章Top 10","date":"2020-10-13T11:47:56.000Z","updated":"2020-10-13T13:03:24.000Z","comments":false,"path":"Top/index.html","permalink":"https://www.whitemoon.top/Top/index.html","excerpt":"","text":"AV.initialize(\"F0f5yVbiwzDOadqfHenPALgr-MdYXbMMI\", \"q23DFE2S8G7CuPsbfLxHrADI\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"},{"title":"关于","date":"2020-10-11T17:10:36.000Z","updated":"2022-08-21T04:57:30.000Z","comments":true,"path":"about/index.html","permalink":"https://www.whitemoon.top/about/index.html","excerpt":"","text":"在校大学生一名，计科专业，19年萌出建博客记录学习过程的想法，20年疫情闲的无聊就建了wordpress博客，后来由于vps不稳定就关闭了，就转为Github Page双线搭建博客 博客随缘更新，无聊的时候或者有必要就写写"},{"title":"留言板","date":"2022-08-21T11:31:45.000Z","updated":"2022-08-21T12:16:28.000Z","comments":true,"path":"contact/index.html","permalink":"https://www.whitemoon.top/contact/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-11T17:10:07.000Z","updated":"2022-08-21T04:57:02.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.whitemoon.top/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2022-08-21T07:04:21.000Z","updated":"2022-08-21T07:24:50.000Z","comments":true,"path":"gallery/index.html","permalink":"https://www.whitemoon.top/gallery/index.html","excerpt":"","text":""},{"title":"","date":"2023-10-27T01:07:05.578Z","updated":"2020-10-11T18:55:38.000Z","comments":true,"path":"commonweal/404.html","permalink":"https://www.whitemoon.top/commonweal/404.html","excerpt":"","text":""},{"title":"主页","date":"2020-10-12T13:10:50.000Z","updated":"2020-10-12T17:43:20.000Z","comments":false,"path":"home/index.html","permalink":"https://www.whitemoon.top/home/index.html","excerpt":"","text":"主人很懒，什么都没有留下O__O “…"},{"title":"me","date":"2022-08-21T07:04:25.000Z","updated":"2022-08-21T07:04:26.000Z","comments":true,"path":"me/index.html","permalink":"https://www.whitemoon.top/me/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-11T17:10:19.000Z","updated":"2022-08-21T04:55:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.whitemoon.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自建的代理节点转换站点","slug":"自建的代理节点转换站点","date":"2022-09-18T06:58:39.000Z","updated":"2022-09-21T11:25:43.259Z","comments":true,"path":"2022/09/18/zi-jian-de-dai-li-jie-dian-zhuan-huan-zhan-dian/","link":"","permalink":"https://www.whitemoon.top/2022/09/18/zi-jian-de-dai-li-jie-dian-zhuan-huan-zhan-dian/","excerpt":"利用Sub-Store搭建自己的代理节点转换站","text":"自建代理转换节点Github Peng-YM大佬的Sub-Store提供了几乎全平台的代理转换，Loon、Surge等可以安装其提供的模块直接使用，本教程是将Sub-Store搭建为网站，更方便clash等使用 前期准备 域名 证书 服务器vps 服务器需要安装好nginx，并提前上传证书，开放端口 域名购买后可以添加二级域名解析，如购买的域名为 zqzess.com,添加一个sub.zqzess.com 克隆并运行项目 名称 地址 前端 Sub-Store-Front-End https://github.com/sub-store-org/Sub-Store-Front-End.git 后端 Sub-Store/backend https://github.com/sub-store-org/Sub-Store.git 使用 git clone + 地址的方式克隆 安装 pnpm npm i pnpm -g 在前端 Sub-Store-Front-End文件夹下执行pnpm i 安装依赖 依赖安装完成后，执行pnpm dev既可以使用浏览器打开http://localhost:8888/ 浏览器出现下面的页面即代表成功运行此时由于没有运行后端，所以会出现数据加载失败 修改Sub-Store前端修改后端接口地址可以使用WebStorm或者VScode打开前端项目 打开项目根目录下的.env.production文件，将文件里线上环境接口地址改为自己准备的域名，比如https://sub.zqzess.top 添加登陆页面由于是要部署到服务器上，即为公开的，所以还需要一个登陆页面，阻止任何人访问 在项目根目录下的src/views下新建Login.vue文件 Login.vue代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;template&gt; &lt;div class=&#x27;wrapper&#x27;&gt; &lt;div&gt;欢迎使用&lt;/div&gt; &lt;nut-form :model-value=&#x27;formData&#x27; ref=&#x27;ruleForm&#x27;&gt; &lt;nut-form-item label=&#x27;用户名&#x27; prop=&#x27;name&#x27; required :rules=&quot;[&#123; required: true, message: &#x27;请填写用户名&#x27; &#125;]&quot;&gt; &lt;input class=&#x27;nut-input-text&#x27; @blur=&quot;customBlurValidate(&#x27;name&#x27;)&quot; v-model=&#x27;formData.name&#x27; placeholder=&#x27;请输入用户名&#x27; type=&#x27;text&#x27; /&gt; &lt;/nut-form-item&gt; &lt;nut-form-item label=&#x27;密码&#x27; prop=&#x27;pwd&#x27; required :rules=&quot;[ &#123; required: true, message: &#x27;请填写密码&#x27; &#125;, // &#123; validator: customValidator, message: &#x27;必须输入数字&#x27; &#125;, // &#123; regex: /^(\\d&#123;1,2&#125;|1\\d&#123;2&#125;|200000000)$/, message: &#x27;必须输入0-200000000区间&#x27; &#125; ]&quot;&gt; &lt;input class=&#x27;nut-input-text&#x27; v-model=&#x27;formData.pwd&#x27; placeholder=&#x27;请输入密码&#x27; type=&#x27;text&#x27; /&gt; &lt;/nut-form-item&gt; &lt;nut-cell&gt; &lt;nut-button type=&#x27;primary&#x27; size=&#x27;small&#x27; style=&#x27;margin-right: 10px&#x27; @click=&#x27;submit&#x27;&gt;登录&lt;/nut-button&gt; &lt;nut-button size=&#x27;small&#x27; @click=&#x27;reset&#x27;&gt;重置&lt;/nut-button&gt; &lt;/nut-cell&gt; &lt;/nut-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&#x27;ts&#x27;&gt; import &#123; Notify, Toast &#125; from &#x27;@nutui/nutui&#x27;; import &#123; ref, reactive &#125; from &#x27;vue&#x27;; import &#123; useRouter &#125; from &#x27;vue-router&#x27;; export default &#123; setup() &#123; const router = useRouter(); const formData = reactive(&#123; name: &#x27;&#x27;, pwd: &#x27;&#x27;, &#125;); const validate = (item: any) =&gt; &#123; console.log(item); &#125;; const ruleForm = ref&lt;any&gt;(null); const submit = () =&gt; &#123; ruleForm.value.validate().then((&#123; valid, errors &#125;: any) =&gt; &#123; if (valid) &#123; console.log(&#x27;success&#x27;, formData); if (formData.name == &#x27;name&#x27;) &#123; if (formData.pwd == &#x27;password&#x27;) &#123; Notify.success(&#x27;登录成功,欢迎回来！&#x27;,&#123; duration: 1000 &#125;); Toast.loading(&#x27;&#x27;, &#123; cover: false // 透明罩 &#125;); sessionStorage.setItem(&#x27;token&#x27;, &#x27;token&#x27;) // 临时存储，关闭标签后就清除 setTimeout(() =&gt; &#123; router.push(&#123;path: &#x27;/sub&#x27;&#125;); // router.replace(&#x27;/sub&#x27;) Toast.hide(); &#125;, 1200); &#125; else &#123; Notify.danger(&#x27;密码错误!&#x27;); &#125; &#125; else &#123; Notify.warn(&#x27;用户不存在!&#x27;); &#125; &#125; else &#123; console.log(&#x27;error submit!!&#x27;, errors); &#125; &#125;); &#125;; const reset = () =&gt; &#123; ruleForm.value.reset(); &#125;; // 失去焦点校验 const customBlurValidate = (prop: string) =&gt; &#123; ruleForm.value.validate(prop).then((&#123; valid, errors &#125;: any) =&gt; &#123; if (valid) &#123; console.log(&#x27;success&#x27;, formData); &#125; else &#123; console.log(&#x27;error submit!!&#x27;, errors); &#125; &#125;); &#125;; // 函数校验 const customValidator = (val: string) =&gt; /^\\d+$/.test(val); // Promise 异步校验 const asyncValidator = (val: string) =&gt; &#123; return new Promise((resolve) =&gt; &#123; Toast.loading(&#x27;模拟异步验证中...&#x27;); setTimeout(() =&gt; &#123; Toast.hide(); resolve(/^400(-?)[0-9]&#123;7&#125;$|^1\\d&#123;10&#125;$|^0[0-9]&#123;2,3&#125;-[0-9]&#123;7,8&#125;$/.test(val)); &#125;, 1000); &#125;); &#125;; return &#123; ruleForm, formData, validate, customValidator, asyncValidator, customBlurValidate, submit, reset &#125;; &#125;, &#125;;&lt;/script&gt;&lt;style lang=&#x27;scss&#x27; scoped&gt; .wrapper &#123; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; h3 &#123; padding-bottom: 24px; &#125; &#125;&lt;/style&gt; 修改代码中的用户名、密码、token 示例： 1234567if (formData.name == &#x27;zqzess&#x27;) &#123; if (formData.pwd == &#x27;zqzess&#x27;) &#123; Notify.success(&#x27;登录成功,欢迎回来！&#x27;,&#123; duration: 1000 &#125;); Toast.loading(&#x27;&#x27;, &#123; cover: false // 透明罩 &#125;); sessionStorage.setItem(&#x27;token&#x27;, &#x27;code&#x27;) // 临时存储，关闭标签后就清除 此处sessionStorage.setItem(&#39;token&#39;, &#39;code&#39;)定义的token为code，一定要记住，后面路由会用到 此处formData.name == &#39;zqzess&#39;定义的zqzess即为用户名 此处formData.pwd == &#39;zqzess&#39;定义的zqzess即为密码 1这种明文写在代码里面账号密码其实也不安全，仅作为一个简单的认证，以后有机会再改写需要后端认证的登陆 修改路由接下来需要把登陆页面添加至路由里面，并加入拦截，没有token的需要跳转登陆页 项目根目录/src/router/index.ts 添加import Login from &#39;@/views/Login.vue&#39;; 接着修改根路由，将如下代码修改为图片上的 123456789101112131415routes: [ &#123; path: &#x27;/&#x27;, component: AppLayout, redirect: &#x27;/subs&#x27;, children: [ &#123; path: &#x27;/subs&#x27;, component: Sub, meta: &#123; title: &#x27;sub&#x27;, needTabBar: true, needNavBack: false, &#125;, &#125;, 即将第一个path: &#39;/&#39;改为path: &#39;/sub&#39; 接着添加登陆路由在path: &#39;/:pathMatch(.*)&#39;代码后面添加 12345678910111213141516171819&#123; path: &#x27;/:pathMatch(.*)&#x27;, component: NotFound, meta: &#123; title: &#x27;notFound&#x27;, needTabBar: false, needNavBack: true, &#125;,&#125;,&#123; path: &#x27;/&#x27;, component: Login, meta: &#123; title: &#x27;login&#x27;, needTabBar: false, needNavBack: false, &#125;,&#125; 在本页最后一行export default router;上面添加路由拦截 12345678910111213141516171819202122router.beforeEach((to, from, next) =&gt; &#123; // let token = window.localStorage.getItem(&#x27;token&#x27;) // let type = window.localStorage.getItem(&#x27;type&#x27;) if (to.path === &#x27;/&#x27; || to.path === &#x27;/login&#x27; || to.path === &#x27;/error&#x27;) &#123; // console.log(&quot;允许直接访问&quot;) next(); &#125; else &#123; // let token = window.localStorage.getItem(&#x27;token&#x27;) // 长期存储 let token = window.sessionStorage.getItem(&#x27;token&#x27;) // 临时存储，关闭标签后就清除 // console.log(&quot;需要token&quot;) if (token === null || token === &#x27;&#x27; || token !== &#x27;code&#x27;) &#123; // console.log(&quot;无token，跳转登录&quot;) next(&#x27;/&#x27;); &#125; else &#123; // console.log(&quot;有token&quot;) next(); &#125; &#125;&#125;);export default router; 此处if (token === null || token === &#39;&#39; || token !== &#39;code&#39;) &#123;的code即为上面登陆页填写的token 接着修改根目录/src/views/SubEditor.vue由于代码较多，可以直接搜索router.replace,会跳转到相应代码把router.replace(&#39;/&#39;)改为router.replace(&#39;/sub&#39;) 登陆页的命名与翻译根目录/src/locales/en.ts 可以使用搜索notFound: &#39;404 Not Found&#39;,,再此行下面添加login: &#39;Login&#39;, 12345678910111213141516pagesTitle: &#123; sub: &#x27;Subscription Management&#x27;, sync: &#x27;Sync Subscription&#x27;, my: &#x27;My Profile&#x27;, subEditor: &#x27;Subscription Editor&#x27;, themeSetting: &#x27;Theme Setting&#x27;, notFound: &#x27;404 Not Found&#x27;, login: &#x27;Login&#x27;, askWhat: &#123; sync: &#123; title: &#x27;What is Sync Subscription?&#x27;, content: &#x27;Upload your subscriptions to a private Gist, which can be accessed at any time on devices that do not run the Sub Store (e.g. routers, etc.).&#x27;, &#125;, &#125;, &#125;, 同样 根目录/src/locales/zh.ts搜索notFound: &#39;地址未找到&#39;,,再此行下面添加login: &#39;登录&#39;, 12345678910111213141516pagesTitle: &#123; sub: &#x27;订阅管理&#x27;, sync: &#x27;同步订阅&#x27;, my: &#x27;我的&#x27;, subEditor: &#x27;订阅编辑&#x27;, themeSetting: &#x27;主题设置&#x27;, notFound: &#x27;地址未找到&#x27;, login: &#x27;登录&#x27;, askWhat: &#123; sync: &#123; title: &#x27;什么是同步订阅？&#x27;, content: &#x27;将您的订阅信息上传到私有 Gist，在无法运行 Sub Store 的设备（例如路由器等）上也可以随时访问。&#x27;, &#125;, &#125;, &#125;, 至此已经全部结束，接下来就是打包发布并部署服务器 前端打包在根目录下进入终端命令，执行``pnpm build`，然后等待其打包好 打包好后，根目录会多出dist文件夹，此文件夹就是打包好的网站文件，也是我们需要发布服务器的 上传服务器并配置启动后端在服务器上找一个文件夹存放前后端文件这是我的前端存放目录 再找一个文件夹把后端项目里的backend文件夹上传这是我的后端存放目录 命令行进入后端存放目录，执行pnpm i 完成后再执行pm2 start /home/Sub-Store-new/backend/sub-store.min.js，完成后继续执行pm2 save,如果成功，至此后端已经成功启动 pm2需要先安装好 配置Nginx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;stream &#123; # 这里就是 SNI 识别，将域名映射成一个配置名，请修改自己的一级域名 map $ssl_preread_server_name $backend_name &#123; sub.whitemoon.top sub; # 域名都不匹配情况下的默认值 default web; &#125; upstream sub &#123; server 127.0.0.1:10244; &#125; # 监听 443 并开启 ssl_preread server &#123; listen 443 reuseport; listen [::]:443 reuseport; proxy_pass $backend_name; ssl_preread on; &#125;&#125;http &#123; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf;server &#123; # 开启 HTTP2 支持 listen 10244 ssl http2; server_name sub.zqzess.com; # root /home/Sub-Store-new/web/dist; # index index.html; gzip on; gzip_http_version 1.1; gzip_vary on; gzip_comp_level 6; gzip_proxied any; gzip_types text/plain text/css application/json application/javascript application/x-javascript text/javascript; ssl_protocols TLSv1.2 TLSv1.3; ssl_certificate /usr/share/nginx/key/1_sub.zqzess.com_bundle.crt; ssl_certificate_key /usr/share/nginx/key/2_sub.zqzess.com.key; ssl_session_cache shared:SSL:10m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # # WS 协议转发 # location /fTY9Bx7c &#123; # proxy_redirect off; # proxy_http_version 1.1; # proxy_set_header Upgrade $http_upgrade; # proxy_set_header Connection &quot;upgrade&quot;; # proxy_set_header Host $http_host; # proxy_pass http://127.0.0.1:16881; # &#125; # location / &#123; # proxy_pass http://127.0.0.1:3000; # &#125; location / &#123; root /home/Sub-Store-new/web/dist; index index.html index.htm; try_files $uri $uri/ /index.html; &#125; location /api &#123; proxy_pass http://127.0.0.1:3000; &#125; location /download &#123; proxy_pass http://127.0.0.1:3000; &#125;&#125;&#125; 完结最后访问自己的域名查看效果 参考Sub-Store","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://www.whitemoon.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"自建代理转换","slug":"科学上网/自建代理转换","permalink":"https://www.whitemoon.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/%E8%87%AA%E5%BB%BA%E4%BB%A3%E7%90%86%E8%BD%AC%E6%8D%A2/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://www.whitemoon.top/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"代理转换","slug":"代理转换","permalink":"https://www.whitemoon.top/tags/%E4%BB%A3%E7%90%86%E8%BD%AC%E6%8D%A2/"}],"author":"zqzess"},{"title":"vue实现语言识别与录音","slug":"vue实现语言识别与录音","date":"2022-08-21T02:36:35.000Z","updated":"2022-08-30T02:08:40.000Z","comments":true,"path":"2022/08/21/vue-shi-xian-yu-yan-shi-bie-yu-lu-yin/","link":"","permalink":"https://www.whitemoon.top/2022/08/21/vue-shi-xian-yu-yan-shi-bie-yu-lu-yin/","excerpt":"基于web原生api实现语音转文字以及录音","text":"vue实现语言识别与录音前言实习的时候，领导要求验证一下在web前端实现录音和语音识别，查了一下发现网上有关语音识别也就是语音转文字几乎没有任何教程。 其实有一种方案，前端先录音然后把录音传到后端，后端在请求如百度语音转文字的api进行识别，但是这种就需要再写个后端。如果直接前端请求百度api会遇到跨域问题，何况apikey等写在前端总感觉不是很安全。再一个百度的识别准确率不是很高。。 由此就有了本篇的由来，基于web原生的api实现语音识别 环境 名称 版本 node v17.1.0 npm 8.1.4 @vue/cli 4.5.15 vue 2 vant 2 适配率 由图可知常用的浏览器基本都支持，但是实际经过测试，谷歌浏览器由于网络原因时灵时不灵，pc上edge识别表现最好，安卓设备几乎都不可用，苹果ios上用safari完美使用 录音与语音识别HZRecorder.js封装这里提供一个网上找来的封装好的js HZRecorder.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160function HZRecorder (stream, config) &#123; config = config || &#123;&#125; config.sampleBits = config.sampleBits || 16 // 采样数位 8, 16 config.sampleRate = config.sampleRate || 16000 // 采样率16khz let context = new (window.webkitAudioContext || window.AudioContext)() let audioInput = context.createMediaStreamSource(stream) let createScript = context.createScriptProcessor || context.createJavaScriptNode let recorder = createScript.apply(context, [4096, 1, 1]) let audioData = &#123; size: 0 // 录音文件长度 , buffer: [] // 录音缓存 , inputSampleRate: context.sampleRate // 输入采样率 , inputSampleBits: 16 // 输入采样数位 8, 16 , outputSampleRate: config.sampleRate // 输出采样率 , oututSampleBits: config.sampleBits // 输出采样数位 8, 16 , input: function (data) &#123; this.buffer.push(new Float32Array(data)) this.size += data.length &#125; , compress: function () &#123; // 合并压缩 // 合并 let data = new Float32Array(this.size) let offset = 0 for (let i = 0; i &lt; this.buffer.length; i++) &#123; data.set(this.buffer[i], offset) offset += this.buffer[i].length &#125; // 压缩 let compression = parseInt(this.inputSampleRate / this.outputSampleRate) let length = data.length / compression let result = new Float32Array(length) // eslint-disable-next-line one-var let index = 0, j = 0 while (index &lt; length) &#123; result[index] = data[j] j += compression index++ &#125; return result &#125; , encodeWAV: function () &#123; let sampleRate = Math.min(this.inputSampleRate, this.outputSampleRate) let sampleBits = Math.min(this.inputSampleBits, this.oututSampleBits) let bytes = this.compress() let dataLength = bytes.length * (sampleBits / 8) let buffer = new ArrayBuffer(44 + dataLength) let data = new DataView(buffer) let channelCount = 1// 单声道 let offset = 0 let writeString = function (str) &#123; for (let i = 0; i &lt; str.length; i++) &#123; data.setUint8(offset + i, str.charCodeAt(i)) &#125; &#125; // 资源交换文件标识符 writeString(&#x27;RIFF&#x27;) offset += 4 // 下个地址开始到文件尾总字节数,即文件大小-8 data.setUint32(offset, 36 + dataLength, true) offset += 4 // WAV文件标志 writeString(&#x27;WAVE&#x27;) offset += 4 // 波形格式标志 writeString(&#x27;fmt &#x27;) offset += 4 // 过滤字节,一般为 0x10 = 16 data.setUint32(offset, 16, true) offset += 4 // 格式类别 (PCM形式采样数据) data.setUint16(offset, 1, true) offset += 2 // 通道数 data.setUint16(offset, channelCount, true) offset += 2 // 采样率,每秒样本数,表示每个通道的播放速度 data.setUint32(offset, sampleRate, true) offset += 4 // 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8 data.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), true) offset += 4 // 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8 data.setUint16(offset, channelCount * (sampleBits / 8), true) offset += 2 // 每样本数据位数 data.setUint16(offset, sampleBits, true) offset += 2 // 数据标识符 writeString(&#x27;data&#x27;) offset += 4 // 采样数据总数,即数据总大小-44 data.setUint32(offset, dataLength, true) offset += 4 // 写入采样数据 if (sampleBits === 8) &#123; for (let i = 0; i &lt; bytes.length; i++, offset++) &#123; let s = Math.max(-1, Math.min(1, bytes[i])) let val = s &lt; 0 ? s * 0x8000 : s * 0x7FFF val = parseInt(255 / (65535 / (val + 32768))) data.setInt8(offset, val, true) &#125; &#125; else &#123; for (let i = 0; i &lt; bytes.length; i++, offset += 2) &#123; let s = Math.max(-1, Math.min(1, bytes[i])) data.setInt16(offset, s &lt; 0 ? s * 0x8000 : s * 0x7FFF, true) &#125; &#125; return new Blob([data], &#123;type: &#x27;audio/wav&#x27;&#125;) &#125; &#125; // 开始录音 this.start = function () &#123; audioInput.connect(recorder) recorder.connect(context.destination) &#125; // 停止 this.stop = function () &#123; recorder.disconnect() &#125; // 获取音频文件 this.getBlob = function () &#123; this.stop() console.log(audioData.encodeWAV()) return audioData.encodeWAV() &#125; // 回放 this.play = function (audio) &#123; let blob = this.getBlob() // saveAs(blob, &quot;F:/3.wav&quot;); // window.open(window.URL.createObjectURL(this.getBlob())) audio.src = window.URL.createObjectURL(this.getBlob()) &#125; // 上传 this.upload = function () &#123; return this.getBlob() &#125; // 音频采集 recorder.onaudioprocess = function (e) &#123; audioData.input(e.inputBuffer.getChannelData(0)) // record(e.inputBuffer.getChannelData(0)); &#125; return this&#125;export &#123; HZRecorder&#125; VueJs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;template&gt; &lt;div id=&quot;page&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div&gt; &lt;div style=&quot;display: block;align-items: center;text-align: center;&quot;&gt; &lt;label&gt;识别结果: &#123;&#123; result &#125;&#125;&lt;/label&gt; &lt;/div&gt; &lt;div style=&quot;display: block;align-items: center;text-align: center;margin: 20px 0 20px 0&quot;&gt; &lt;label&gt;识别结果2: &#123;&#123; result2 &#125;&#125;&lt;/label&gt; &lt;/div&gt; &lt;audio ref=&quot;audiodiv&quot; type=&quot;audio/wav&quot; controls /&gt; &lt;/div&gt; &lt;div style=&quot;display: inline-flex;margin: 20px 0 20px 0&quot;&gt; &lt;van-button type=&quot;warning&quot; @click=&quot;speakClick&quot; square &gt;识别点击说话 &lt;/van-button&gt; &lt;van-button type=&quot;warning&quot; @click=&quot;speakEndClick&quot; square &gt;识别结束说话 &lt;/van-button&gt; &lt;/div&gt; &lt;div&gt; &lt;van-button type=&quot;warning&quot; @click=&quot;speakClick2&quot; square &gt;录音点击说话 &lt;/van-button&gt; &lt;van-button type=&quot;warning&quot; @click=&quot;speakEndClick2&quot; square &gt;录音关闭说话 &lt;/van-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;HZRecorder&#125; from &#x27;../js/HZRecorder&#x27;import &#123;Toast&#125; from &#x27;vant&#x27;export default &#123; name: &#x27;home&#x27;, data () &#123; return &#123; recorder: &#x27;&#x27;, recognition: &#x27;&#x27;, audioSrc: &#x27;&#x27;, result: &#x27;&#x27;, result2: &#x27;&#x27; &#125; &#125;, created () &#123; const vue = this if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) &#123; this.getUserMedia(&#123; video: false, audio: true &#125;) // 调用用户媒体设备，访问摄像头、录音 &#125; else &#123; console.log(&#x27;你的浏览器不支持访问用户媒体设备&#x27;) &#125; &#125;, methods: &#123; speakClick () &#123; const vue = this vue.result2 = &#x27;&#x27; vue.result = &#x27;&#x27; console.log(&#x27;start识别&#x27;) let SpeechRecognition = window.SpeechRecognition || window.mozSpeechRecognition || window.webkitSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition if (SpeechRecognition) &#123; vue.recognition = new SpeechRecognition() vue.recognition.continuous = true vue.recognition.interimResults = true vue.recognition.lang = &#x27;cmn-Hans-CN&#x27; // 普通话 (中国大陆) &#125; vue.recognition.start() vue.recognition.onstart = function () &#123; console.log(&#x27;识别开始...&#x27;) &#125; // eslint-disable-next-line one-var let final_transcript = &#x27;&#x27;, interim_transcript = &#x27;&#x27; vue.recognition.onerror = function (event) &#123; console.log(&#x27;识别出错&#x27;) console.log(event) if (event.error == &#x27;no-speech&#x27;) &#123; console.log(&#x27;no-speech&#x27;) &#125; if (event.error == &#x27;audio-capture&#x27;) &#123; console.log(&#x27;audio-capture&#x27;) &#125; if (event.error == &#x27;not-allowed&#x27;) &#123; console.log(&#x27;not-allowed&#x27;) &#125; &#125; vue.recognition.onresult = function (event) &#123; console.log(&#x27;识别成功&#x27;) if (typeof (event.results) == &#x27;undefined&#x27;) &#123; console.log(&#x27;识别结果undefined&#x27;) vue.recognition.onend = null vue.recognition.stop() &#125; else &#123; console.log(event.results) for (let i = event.resultIndex; i &lt; event.results.length; ++i) &#123; if (event.results[i].isFinal) &#123; final_transcript += event.results[i][0].transcript &#125; else &#123; interim_transcript += event.results[i][0].transcript &#125; &#125; final_transcript = capitalize(final_transcript) console.log(&#x27;final_transcript: &#x27; + final_transcript) console.log(&#x27;interim_transcript: &#x27; + interim_transcript) if (final_transcript != &#x27;undefined&#x27;) &#123; vue.result = final_transcript &#125; if (interim_transcript != &#x27;undefined&#x27;) &#123; vue.result2 = interim_transcript &#125; &#125; &#125; var two_line = /\\n\\n/g var one_line = /\\n/g function linebreak (s) &#123; return s.replace(two_line, &#x27;&lt;p&gt;&lt;/p&gt;&#x27;).replace(one_line, &#x27;&lt;br&gt;&#x27;) &#125; let first_char = /\\S/ function capitalize (s) &#123; return s.replace(first_char, function (m) &#123; return m.toUpperCase() &#125;) &#125; &#125;, speakEndClick () &#123; const vue = this console.log(&#x27;end识别&#x27;) vue.recognition.stop() // 识别停止 vue.recognition.onend = function () &#123; console.log(&#x27;识别结束&#x27;) &#125; &#125;, speakClick2 () &#123; const vue = this console.log(&#x27;start&#x27;) vue.recorder.start() // 录音 &#125;, speakEndClick2 () &#123; const vue = this console.log(&#x27;end&#x27;) let audioData = new FormData() audioData.append(&#x27;speechFile&#x27;, vue.recorder.getBlob()) vue.recorder.play(this.$refs.audiodiv) &#125;, getUserMedia (constrains) &#123; let that = this if (navigator.mediaDevices.getUserMedia) &#123; // 最新标准API navigator.mediaDevices.getUserMedia(constrains).then(stream =&gt; &#123; that.success(stream) that.recorder = new HZRecorder(stream) console.log(&#x27;录音初始化准备完成&#x27;) &#125;).catch(err =&gt; &#123; that.error(err) &#125;) &#125; else if (navigator.webkitGetUserMedia) &#123; // webkit内核浏览器 navigator.webkitGetUserMedia(constrains).then(stream =&gt; &#123; that.success(stream) that.recorder = new HZRecorder(stream) console.log(&#x27;录音初始化准备完成&#x27;) &#125;).catch(err =&gt; &#123; that.error(err) &#125;) &#125; else if (navigator.mozGetUserMedia) &#123; // Firefox浏览器 navigator.mozGetUserMedia(constrains).then(stream =&gt; &#123; that.success(stream) that.recorder = new HZRecorder(stream) console.log(&#x27;录音初始化准备完成&#x27;) &#125;).catch(err =&gt; &#123; that.error(err) &#125;) &#125; else if (navigator.getUserMedia) &#123; // 旧版API navigator.getUserMedia(constrains).then(stream =&gt; &#123; that.success(stream) that.recorder = new HZRecorder(stream) console.log(&#x27;录音初始化准备完成&#x27;) &#125;).catch(err =&gt; &#123; that.error(err) &#125;) &#125; &#125;, // 成功的回调函数 success (stream) &#123; console.log(&#x27;已点击允许,开启成功&#x27;) &#125;, // 异常的回调函数 error (error) &#123; console.log(&#x27;访问用户媒体设备失败：&#x27;, error.name, error.message) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#page&#123; position: absolute; display: flex; width: 100%; height: 100%; align-items: center; text-align: center; vertical-align: middle;&#125;.content&#123; width: 30%; height: 30%; margin: 0 auto;&#125;&lt;/style&gt; 识别效果ChromeSafariios Safari 重要在localhost下可以申请并开启麦克风权限，其它环境下需要配置https才可以申请并开启麦克风权限 参考文档Web APIs | MDN","categories":[{"name":"前端","slug":"前端","permalink":"https://www.whitemoon.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.whitemoon.top/tags/Vue/"},{"name":"web","slug":"web","permalink":"https://www.whitemoon.top/tags/web/"},{"name":"前端","slug":"前端","permalink":"https://www.whitemoon.top/tags/%E5%89%8D%E7%AB%AF/"}],"author":"zqzess"},{"title":"N1掉盘临时解决办法","slug":"N1掉盘临时解决办法","date":"2021-01-27T14:20:41.000Z","updated":"2023-10-27T03:39:23.189Z","comments":true,"path":"2021/01/27/n1-diao-pan-lin-shi-jie-jue-ban-fa/","link":"","permalink":"https://www.whitemoon.top/2021/01/27/n1-diao-pan-lin-shi-jie-jue-ban-fa/","excerpt":"","text":"前言 最近入了N1的坑,刷了armbian系统,做emby服务器,然后就遇到了个大坑 我的移动硬盘是东芝的，自带休眠，一开始正常使用，过后就发现会掉盘 体现在ls命令上 ls: reading directory &#39;.&#39;: Input/output error 使用lsblk命令发现sda会变sdb,sdc…. 百度一圈，都是在/etc/fstab 加入uuid识别挂载，但是这样不管用啊，还是掉盘，一掉盘得手动重新挂载或者重启n1 暂时解决办法 由于不知道到底是什么原因导致的，只能写个小脚本解决， 思路: 每30秒ls检查一次，ls失败则自动挂载 添加uuid识别挂载: lsblk查看分区信息 如图，我的是sda-sda1，挂载点是/mnt/sda1 blkid查看分区uuid 如图，我硬盘标签的是LABEL=&quot;TOSHIBA&quot; uuid是 UUID=&quot;D282A4C682A4B081&quot; 格式是 TYPE=&quot;ntfs&quot; 在fstab添加uuid识别挂载 编辑 /etc/fstab vi编辑或者winscp登陆n1直接编辑文件 最后一行加入 uuid= /mnt/sda1 auto defaults 0 0 保存后执行mount -a 制作shell脚本自动检测掉盘重新挂载 检测脚本 automount.sh -&gt;不会用的可以创建txt文本然后修改为.sh，再用winscp上传至/home下 12345678#!/bin/bashif ls &#x27;/mnt/sda1&#x27; 2&gt;&amp;1then echo &quot;mounted&quot;else echo &quot;not mounted&quot; mount -afi 每30秒执行 由于cron定时任务最低1分钟执行，所以得再写一个脚本停顿30秒再执行 keep.sh 123456#!/bin/bashdate +&#x27;%Y-%m-%d %H:%M:%S&#x27;/home/automount.shsleep 30date +&#x27;%Y-%m-%d %H:%M:%S&#x27;/home/automount.sh 上面两个脚本都放在/home下 赋予权限 12chmod 777 -R /home/automount.shchmod 777 -R /home/keep.sh 添加定时任务 执行crontab -e 12 * * * * * /home/keep.sh &gt;&gt; /home/log.txt0 0 12 * * ? /home/autoremove.sh 如果不想保留日志,用下面的写法 1* * * * * /home/keep.sh 完成后执行crontab -l可以查看定时任务 ps 用这种方法我的硬盘由于是自带休眠的，所以依旧能正常休眠 但是 过段时间它会被ls指令唤醒，只是唤醒后不会转，只有指示灯亮，硬盘应该不会由过多磨损","categories":[{"name":"Armbian","slug":"Armbian","permalink":"https://www.whitemoon.top/categories/Armbian/"},{"name":"N1","slug":"Armbian/N1","permalink":"https://www.whitemoon.top/categories/Armbian/N1/"}],"tags":[{"name":"N1","slug":"N1","permalink":"https://www.whitemoon.top/tags/N1/"},{"name":"Armbian","slug":"Armbian","permalink":"https://www.whitemoon.top/tags/Armbian/"}]},{"title":"Hexo+GitHub Page搭建个人博客","slug":"Hexo-GitHub-Page搭建个人博客","date":"2020-10-12T19:45:36.000Z","updated":"2022-09-18T14:00:26.894Z","comments":true,"path":"2020/10/13/hexo-github-page-da-jian-ge-ren-bo-ke/","link":"","permalink":"https://www.whitemoon.top/2020/10/13/hexo-github-page-da-jian-ge-ren-bo-ke/","excerpt":"","text":"记一次使用Github Page和hexo搭建个人博客我用到的工具： PicGo:图床管理,github下载 ShareX:截图,steam免费下载 环境与安装 安装好node和git，并注册号github账号 Git Nodejs GitHub Git下载 Nodejs下载 GitHub注册 检查版本 123git versionnode -vnpm -v 安装hexo 创建一个文件夹，文件夹内右键Git Bash Here 执行:npm install -g hexo-cli 安装好后，执行以下命令，在新文件夹创建所需文件 123hexo init myBlogcd myBlognpm install 安装好后，myBlog文件夹的目录如下: 继续执行hexo generate 查看hexo运行效果 git bash终端执行hexo s命令 最后在浏览器中输入http://localhost:4000回车就可以预览效果了 以上是我修改后的主题的预览效果，使用了next主题 接下来就是部署到github了 注册github 注册好，邮箱验证好后，就可以登录了 然后新建一个仓库 ps: 只能使用一个同名仓库托管一个静态站点 由于我已经创建好了，就网上找了张图 下面是我的仓库设置 设置settings里面选择GitHub Page主题 创建好后，就可以访问http://你的用户名.github.io查看初始效果了 配置ssh 监测是否有已经存在的SSH keys: git bash 终端执行:ls -al ~/.ssh 如果有SSH keys: 就会看到如下文件 id_rsa id_rsa.pub (除了我自己生成的这种,官方教程里说,SSH keys也有可能是以下几种文件: id_dsa.pub id_ecdsa.pub id_ed25519.pub) 如果没有的话,就生成一个SSH keys: 先执行以下命令配置本地账户: 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot; ssh-keygen -t rsa -C &quot;上面的邮箱&quot; 然后会出现: 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了. 然后会出现: 12Enter passphrase (empty for no passphrase): [Type a passphrase]# Enter same passphrase again: [Type passphrase again] 冒号后面输入一个密码,这个密码后面会用到,所以要记住! 创建成功后,他会提示你SSH keys保存在哪里: 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 如图: 找到SSH keys: 根据上一步里告诉你的路径,找到保存SSH keys的地方,我的是在 C:\\Users\\zqzes.ssh 其中 id_rsa.pub 就是SSH keys 如果为了防止以后找不到,可以把他们自己另存到其它地方 为github仓库添加SSH keys 打开上面创建的仓库,点击’Settings’,再左侧的’Deploy keys’: 点击’Add deploy key’ 然后把上面创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填. 点击’Add key’ 添加的过程中,还要再输入一次github的密码 测试连接 回到git bash执行ssh -T git@github.com 如上图，一些奇怪的提示，最后问你yes/no，输入yes就好 然后提示你输入密码，如下 1Enter passphrase for key &#x27;/c/Users/zqzes/.ssh/id_rsa&#x27;: 最后它提示你: 1Hi, 用户名/用户名.github.io! You&#x27;ve successfully authenticated, but GitHub does notprovide shell access. 这样就ok了 配置yml准备发布 myBlog内有个文件叫_config.yml,打开它,拉到最底下,做如下修改: 1234deploy: type: &#x27;git&#x27; #这里应为git,如使用github会发生错误 repository: https://github.com/zqzess/zqzess.github.io #把zqzess改成自己的用户名 branch: master 然后git bash执行npm install hexo-deployer-git --save安装部署插件 最后执行以下命令就可以部署上传了 hexo g -d g是generate缩写,d是deploy缩写 然后就可以访问https://你的用户名.github.io查看博客了 写博客 新建文章 git bash执行:hexo new &#39;文章标题&#39; 完成后在/source/_posts下可以看到’文章标题.md’的文件，md是MarkDown的拓展名,网上可以找到它的语法 文章写好依次后执行: 1hexo g 1hexo s 然后可以在http://localhost::4000预览效果 最后，发布到github，依次执行: 1hexo clean 1hexo g -d hexo clean可以请出缓存和已生成静态文件 草稿 git bash执行:``hexo new draft ‘文章标题’ 完成后在/source/_drafts下可以看到草稿 发布草稿执行:hexo publish [layout] &lt;filename&gt; 写在最后主题文件可以放在myBlog/themes/下面后面我会写一篇关于主题美化及容易踩的坑和解决方案 参考资料 使用hexo搭建github.io博客(一) 超详细Hexo+Github Page搭建技术博客教程【持续更新】 三分钟在GitHub上搭建个人博客 搭建自己的github.io博客","categories":[{"name":"博客","slug":"博客","permalink":"https://www.whitemoon.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://www.whitemoon.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.whitemoon.top/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.whitemoon.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://www.whitemoon.top/tags/GitHub-Page/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-07-11T04:41:41.000Z","updated":"2022-08-21T02:31:28.000Z","comments":true,"path":"2020/07/11/hello-world/","link":"","permalink":"https://www.whitemoon.top/2020/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://www.whitemoon.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"自建代理转换","slug":"科学上网/自建代理转换","permalink":"https://www.whitemoon.top/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/%E8%87%AA%E5%BB%BA%E4%BB%A3%E7%90%86%E8%BD%AC%E6%8D%A2/"},{"name":"前端","slug":"前端","permalink":"https://www.whitemoon.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Armbian","slug":"Armbian","permalink":"https://www.whitemoon.top/categories/Armbian/"},{"name":"N1","slug":"Armbian/N1","permalink":"https://www.whitemoon.top/categories/Armbian/N1/"},{"name":"博客","slug":"博客","permalink":"https://www.whitemoon.top/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"博客/Hexo","permalink":"https://www.whitemoon.top/categories/%E5%8D%9A%E5%AE%A2/Hexo/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://www.whitemoon.top/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"代理转换","slug":"代理转换","permalink":"https://www.whitemoon.top/tags/%E4%BB%A3%E7%90%86%E8%BD%AC%E6%8D%A2/"},{"name":"Vue","slug":"Vue","permalink":"https://www.whitemoon.top/tags/Vue/"},{"name":"web","slug":"web","permalink":"https://www.whitemoon.top/tags/web/"},{"name":"前端","slug":"前端","permalink":"https://www.whitemoon.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"N1","slug":"N1","permalink":"https://www.whitemoon.top/tags/N1/"},{"name":"Armbian","slug":"Armbian","permalink":"https://www.whitemoon.top/tags/Armbian/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.whitemoon.top/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.whitemoon.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://www.whitemoon.top/tags/GitHub-Page/"}]}